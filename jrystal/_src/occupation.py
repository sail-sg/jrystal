# Copyright 2025 Garena Online Private Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Occupation module."""
from typing import Optional, Union

import einops
import jax
import jax.numpy as jnp
from jax.lax import stop_gradient
from jaxtyping import Array, Float

from .unitary_module import unitary_matrix, unitary_matrix_param_init
from .utils import check_spin_number


def idempotent_param_init(
  key: Array,
  num_bands: int,
  num_electrons: int,
  num_kpts: int,
  spin: int = 0,
  spin_restricted: bool = True,
) -> dict:
  r"""Initialize the parameters for the idempotent occupation.

  This function is an implementation of the method proposed in:

  `Li, Tianbo, et al. "Diagonalization without Diagonalization: A Direct Optimization Approach for Solid-State Density Functional Theory." arXiv preprint arXiv:2411.05033 (2024).`

  Please also refer to the tutorial :doc:`Occupation <../tutorial/occupation>`  for more details.

  Examples:

  .. code:: python

    from jrystal import occupation
    key = jax.random.PRNGKey(0)
    num_kpts = 1
    num_electrons = 10
    # number of bands must be greater than or equal to
    # (num_electrons + 1) // 2 for spin-restricted calculation.
    num_bands = 10
    params = occupation.idempotent_param_init(key, num_bands, num_kpts)
    occ = occupation.idempotent(params, num_electrons, num_kpts, spin=0)


  Args:
      key (Array): The random key for initialization.
      num_bands (int): The number of bands.
      num_electrons (int): The number of electrons.
      num_kpts (int): The number of :math:`k`-points.
      spin (int, optional): The number of unpaired electrons. Defaults to 0.

  Returns:
      dict: A dictionary containing the initialized parameters.

  """

  check_spin_number(num_electrons, spin)

  num_elec_up = (num_electrons + spin) // 2
  num_elec_down = (num_electrons - spin) // 2

  param_up = unitary_matrix_param_init(
    key, [num_bands * num_kpts, num_elec_up * num_kpts], complex=False
  )
  if spin_restricted:
    return  {"param_up": param_up, "param_down": param_up}

  else:
    param_down = unitary_matrix_param_init(
      key, [num_bands * num_kpts, num_elec_down * num_kpts], complex=False
    )
    return {"param_up": param_up, "param_down": param_down}


def idempotent(
  params: dict,
  num_kpts: int,
  spin_restricted: bool = True,
) -> Float[Array, 'spin kpt band']:
  r"""Calculate the occupation number using the idempotent method.

  This function is an implementation of the method proposed in:

  `Li, Tianbo, et al. "Diagonalization without Diagonalization: A Direct Optimization Approach for Solid-State Density Functional Theory." arXiv preprint arXiv:2411.05033 (2024).`

  Please also refer to the tutorial :doc:`Occupation <../tutorial/occupation>`  for more details.

  Examples:

  .. code:: python

    from jrystal import occupation
    key = jax.random.PRNGKey(0)
    num_kpts = 1
    num_electrons = 10
    # number of bands must be greater than or equal to
    # (num_electrons + 1) // 2 for spin-restricted calculation.
    num_bands = 10
    params = occupation.idempotent_param_init(key, num_bands, num_kpts)
    occ = occupation.idempotent(params, num_electrons, num_kpts, spin=0)

  Args:
      params (dict): The parameters for the idempotent occupation. It can be    generated by :func:`idempotent_param_init`.
      num_kpts (int): The number of :math:`k`-points.
      spin_restricted (bool, optional): Whether to use spin-restricted calculation. Defaults to True.

  Returns:
      Float[Array, 'spin kpt band']: The occupation number.

  """
  param_up = params["param_up"]
  param_down = params["param_down"]

  _up_shape = param_up["w_re"].shape
  _down_shape = param_down["w_re"].shape

  num_bands = _up_shape[0] // num_kpts

  def o(params):
    u = unitary_matrix(params, False)
    # [num_bands * num_kpts, num_elec_up * num_kpts]
    occ = einops.einsum(u, u.T, "nk ik, ik nk -> nk")
    return occ.reshape([num_kpts, num_bands])

  occ_up = o(param_up)
  occ_down = o(param_down)

  if spin_restricted:
    return jnp.expand_dims(occ_up + occ_down, axis=0) / num_kpts
  else:
    return jnp.stack([occ_up, occ_down], axis=0) / num_kpts


def uniform(
  num_k: int,
  num_electrons: int,
  spin: int = 0,
  num_bands: Optional[int] = None,
  spin_restricted: bool = True
) -> Float[Array, 'spin kpt band']:
  """Calculate uniform occupation numbers across k-points.

  This function returns an occupation array where electrons are distributed uniformly across :math:`k`-points. For each :math:`k`-point, the occupation is :math:`1/k` for occupied bands and 0 for unoccupied bands.

  The occupation array has the following structure for each spin channel:

  .. math::

    \\begin{pmatrix}
    1/k & 1/k & 1/k & 0 & \\cdots & 0 \\\\
    1/k & 1/k & 1/k & 0 & \\cdots & 0 \\\\
    \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\
    1/k & 1/k & 1/k & 0 & \\cdots & 0
    \\end{pmatrix}

  where :math:`k` is the number of k-points.

  Args:
      num_k (int): The number of :math:`k`-points.
      num_electrons (int): The number of electrons.
      spin (int, optional): The number of unpaired electrons. Defaults to 0.
      num_bands (int | None, optional): The number of bands (orbitals). If num_bands is not provided, then num_bands is the same as num_electrons.Defaults to None.
      spin_restricted (bool, optional): Indicate spin channel. If True, the first axis of output is 1. If False, the first axis of output is 2. Defaults to True.

  Returns:
      Float[Array, 'spin kpt band']: An occupation array with shape [num_spin, num_k, num_bands], where num_spin=1 if ``spin_restricted`` is True, else num_spin=2. The sum of occupation array equals to ``num_electrons``.
  """
  num_bands = num_electrons if num_bands is None else num_bands

  occ = jnp.zeros([2, num_k, num_bands])
  occ = occ.at[0, :, :(num_electrons + spin) // 2].set(1 / num_k)
  occ = occ.at[1, :, :(num_electrons - spin) // 2].set(1 / num_k)

  if spin_restricted:
    return jnp.sum(occ, axis=0, keepdims=True)

  return occ


def gamma(
  num_k: int,
  num_electrons: int,
  spin: int = 0,
  num_bands: Optional[int] = None,
  spin_restricted: bool = True
) -> Float[Array, 'spin kpt band']:
  r"""Calculate occupation numbers for Gamma point sampling.

  This function returns an occupation array where electrons are placed only at the Gamma point (first :math:`k`-point). For the Gamma point, occupation is 1 for occupied bands and 0 for unoccupied bands. All other :math:`k`-points have zero occupation.

  The occupation array has the following structure for each spin channel:

  .. math::

    \begin{pmatrix}
    1 & 1 & 1 & 0 & \cdots & 0 \\
    0 & 0 & 0 & 0 & \cdots & 0 \\
    \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & 0 & 0 & \cdots & 0
    \end{pmatrix}

  Args:
      num_k (int): The number of k-points.
      num_electrons (int): The number of electrons.
      spin (int, optional): The number of unpaired electrons. Defaults to 0.
      num_bands (int | None, optional): The number of bands (orbitals). If
          num_bands is not provided, then num_bands is the same as num_electrons.
          Defaults to None.
      spin_restricted (bool, optional): Indicate spin channel. If True, the
          first axis of output is 1. If False, the first axis of output is 2.
          Defaults to True.

  Returns:
      Float[Array, 'spin kpt band']: An occupation array with shape [num_spin, num_k, num_bands], where num_spin=1 if ``spin_restricted`` is True, else num_spin=2. The sum of occupation array equals to ``num_electrons``.
  """
  num_bands = num_electrons if num_bands is None else num_bands
  occ = jnp.zeros([2, num_k, num_bands])
  occ = occ.at[0, 0, :(num_electrons + spin) // 2].set(1)
  occ = occ.at[1, 0, :(num_electrons - spin) // 2].set(1)

  if spin_restricted:
    return jnp.sum(occ, axis=0, keepdims=True)

  return occ


def param_init(
  key: Array,
  num_bands: int,
  num_electrons: int,
  num_kpts: int,
  spin: int = 0,
  method: str = "simplex-projector",
  spin_restricted: bool = True
) -> Union[dict, Float[Array, 'spin kpt band']]:
  if method == "idempotent":
    return idempotent_param_init(key, num_bands, num_electrons, num_kpts, spin)
  elif method == "uniform":
    return uniform(num_kpts, num_electrons, spin, num_bands, spin_restricted)
  elif method == "gamma":
    return gamma(num_kpts, num_electrons, spin, num_bands, spin_restricted)
  elif method == "simplex-projector":
    return simplex_projector_init(num_bands, num_kpts)
  else:
    raise ValueError(f"Invalid method: {method}")


def occupation(
  params: dict,
  num_kpts: int,
  num_electrons: Optional[int] = None,
  spin: int = 0,
  method: str = "simplex-projector",
  spin_restricted: bool = True
) -> Float[Array, 'spin kpt band']:
  if method == "idempotent":
    return idempotent(params, num_kpts, spin_restricted)
  elif method == "uniform":
    return stop_gradient(params)
  elif method == "gamma":
    return stop_gradient(params)
  elif method == "simplex-projector":
    return simplex_projector(params, num_electrons, spin, spin_restricted)
  else:
    raise ValueError(f"Invalid method: {method}")


def simplex_projector_init(
  num_bands: int,
  num_kpts: int,
) -> dict:
  n = num_bands * num_kpts
  params_up = (jnp.arange(n) - n//2)*0.1
  params_up = params_up.reshape([num_kpts, num_bands])

  params_down =(jnp.arange(n) - n//2)*0.1
  params_down = params_down.reshape([num_kpts, num_bands])

  return {"param_up": params_up, "param_down": params_down}


def proj(x: jnp.array, sum: jnp.array):
  """project onto the occupation constraint, such that:
    sum(x) = sum
    x >= 0
    x <= 1

  Args:
      x (jnp.array): an 1-D array, must be non-negative and less than 1.
      sum (float): the sum of the output array.

  Returns:
      jnp.array: an 1-D array, the sum of which is ``sum``.
  """
  n = x.shape[0]

  def pushdown(x):
    x_sorted = jnp.sort(x)
    x_sum = jnp.sum(x)
    x_cumsum = jnp.cumsum(x_sorted)
    _rho = (x_sum - sum - x_cumsum) / (n - jnp.arange(n) - 1)
    k = jnp.argmax(x_sorted > _rho)
    _lambda = jax.lax.select(
      k == 0,
      (x_sum - sum) / n,
      (x_sum - sum - x_cumsum.at[k-1].get()) / (n - k)
    )
    return jnp.maximum(x - _lambda, 0.)

  def pushup(x):
    x_sorted = jnp.sort(x)
    x_sum = jnp.sum(x)
    x_sorted = x_sorted.at[::-1].get()
    x_cumsum = jnp.cumsum(x_sorted)
    _rho = (x_sum - sum + (jnp.arange(n) + 1 - x_cumsum)) / (n-jnp.arange(n)-1)
    k = jnp.argmax(x_sorted - _rho < 1.)
    _lambda = jax.lax.select(
      k == 0,
      (sum-x_sum) / n,
      (sum-x_sum-(k- x_cumsum.at[k-1].get())) / (n - k)
    )
    return jnp.minimum(x + _lambda, 1.)

  output = jax.lax.select(jnp.sum(x) <= sum, pushup(x), pushdown(x))
  return output


def simplex_projector(
  params: dict,
  num_electrons: int,
  spin: int = 0,
  spin_restricted: bool = True,
) -> Float[Array, 'spin kpt band']:
  num_kpts = params["param_up"].shape[0]
  num_bands = params["param_up"].shape[1]

  params_up = jax.nn.sigmoid(params["param_up"])
  params_up = jnp.ravel(params_up)
  m_up = (num_electrons + spin) // 2 * num_kpts
  m_down = (num_electrons - spin) // 2 * num_kpts
  occ_up = proj(params_up, m_up) / num_kpts
  occ_up = occ_up.reshape([num_kpts, num_bands])

  params_down = jax.nn.sigmoid(params["param_down"])
  params_down = jnp.ravel(params_down)
  occ_down = proj(params_down, m_down) / num_kpts
  occ_down = occ_down.reshape([num_kpts, num_bands])
  occ = jnp.stack([occ_up, occ_down], axis=0)

  if spin_restricted:
    return jnp.sum(occ, axis=0, keepdims=True)
  else:
    return occ
