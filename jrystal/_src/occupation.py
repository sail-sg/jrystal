"""Occupation module."""
import einops
import jax
import jax.numpy as jnp
from typing import Optional
from jaxtyping import Float, Array
from .unitary_module import unitary_matrix, unitary_matrix_param_init


def idempotent_param_init(
  key: Array, num_bands: int, num_kpts: int
) -> dict:
  r"""Initialize the parameters for the idempotent occupation.
  
  This function is an implementation of the method proposed in:
  
  `Li, Tianbo, et al. "Diagonalization without Diagonalization: A Direct Optimization Approach for Solid-State Density Functional Theory." arXiv preprint arXiv:2411.05033 (2024).`
    
  Please also refer to the tutorial :doc:`Occupation <../tutorial/occupation>`  for more details.
  
  Examples:

  .. code:: python
  
    from jrystal import occupation
    key = jax.random.PRNGKey(0)
    num_kpts = 1
    num_electrons = 10
    # number of bands must be greater than or equal to 
    # (num_electrons + 1) // 2 for spin-restricted calculation.
    num_bands = 10   
    params = occupation.idempotent_param_init(key, num_bands, num_kpts)
    occ = occupation.idempotent(params, num_electrons, num_kpts, spin=0)


  Args:
      key (Array): The random key for initialization.
      num_bands (int): The number of bands.
      num_kpts (int): The number of :math:`k`-points.

  Returns:
      dict: A dictionary containing the initialized parameters.

  """
  
  return unitary_matrix_param_init(
    key, [num_bands * num_kpts, num_bands * num_kpts], complex=False
  )


def idempotent(
  params: dict,
  num_electrons: int,
  num_kpts: int,
  spin: int = 0,
  spin_restricted: bool = True,
) -> Float[Array, 'spin kpt band']:
  r"""Calculate the occupation number using the idempotent method.
  
  This function is an implementation of the method proposed in:
  
  `Li, Tianbo, et al. "Diagonalization without Diagonalization: A Direct Optimization Approach for Solid-State Density Functional Theory." arXiv preprint arXiv:2411.05033 (2024).`
    
  Please also refer to the tutorial :doc:`Occupation <../tutorial/occupation>`  for more details.
  
  Examples:

  .. code:: python
  
    from jrystal import occupation
    key = jax.random.PRNGKey(0)
    num_kpts = 1
    num_electrons = 10
    # number of bands must be greater than or equal to 
    # (num_electrons + 1) // 2 for spin-restricted calculation.
    num_bands = 10   
    params = occupation.idempotent_param_init(key, num_bands, num_kpts)
    occ = occupation.idempotent(params, num_electrons, num_kpts, spin=0)

  Args:
      params (dict): The parameters for the idempotent occupation. It can be    generated by :func:`idempotent_param_init`.
      num_electrons (int): The number of electrons.
      num_kpts (int): The number of :math:`k`-points.
      spin (int, optional): The number of unpaired electrons. Defaults to 0.
      spin_restricted (bool, optional): Whether to use spin-restricted calculation. Defaults to True.

  Returns:
      Float[Array, 'spin kpt band']: The occupation number.
  
  """
  num_bands = params["w_re"].shape[0] // num_kpts

  def o(num_e):
    u = unitary_matrix(params, False)
    indices = jnp.arange(num_bands * num_kpts)
    mask_ones = indices < num_e * num_kpts
    mask_fraction = indices == jnp.floor(num_e * num_kpts)
    fraction = num_e * num_kpts - jnp.floor(num_e * num_kpts)
    f = jnp.where(mask_ones, 1.0, jnp.where(mask_fraction, fraction, 0.0))
    occ = einops.einsum(u, f, u.T, "nk ik, ik, ik nk -> nk")
    return occ.reshape([num_kpts, num_bands]) / num_kpts

  occ = jnp.stack(
    [o((num_electrons - spin) // 2), o((num_electrons + spin) // 2)], axis=0
  )

  if spin_restricted is False:
    return occ
  else:
    return jnp.sum(occ, axis=0, keepdims=True)


def uniform(
  num_k: int,
  num_electrons: int,
  spin: int = 0,
  num_bands: Optional[int] = None,
  spin_restricted: bool = True
) -> Float[Array, 'spin kpt band']:
  """Calculate uniform occupation numbers across k-points.

  This function returns an occupation array where electrons are distributed uniformly across :math:`k`-points. For each :math:`k`-point, the occupation is :math:`1/k` for occupied bands and 0 for unoccupied bands.

  The occupation array has the following structure for each spin channel:

  .. math::

    \\begin{pmatrix}
    1/k & 1/k & 1/k & 0 & \\cdots & 0 \\\\
    1/k & 1/k & 1/k & 0 & \\cdots & 0 \\\\
    \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\
    1/k & 1/k & 1/k & 0 & \\cdots & 0
    \\end{pmatrix}

  where :math:`k` is the number of k-points.

  Args:
      num_k (int): The number of :math:`k`-points.
      num_electrons (int): The number of electrons.
      spin (int, optional): The number of unpaired electrons. Defaults to 0.
      num_bands (int | None, optional): The number of bands (orbitals). If num_bands is not provided, then num_bands is the same as num_electrons.Defaults to None.
      spin_restricted (bool, optional): Indicate spin channel. If True, the first axis of output is 1. If False, the first axis of output is 2. Defaults to True.

  Returns:
      Float[Array, 'spin kpt band']: An occupation array with shape [num_spin, num_k, num_bands], where num_spin=1 if ``spin_restricted`` is True, else num_spin=2. The sum of occupation array equals to num_electrons.
  """
  num_bands = num_electrons if num_bands is None else num_bands

  occ = jnp.zeros([2, num_k, num_bands])
  occ = occ.at[0, :, :(num_electrons + spin) // 2].set(1 / num_k)
  occ = occ.at[1, :, :(num_electrons - spin) // 2].set(1 / num_k)

  if spin_restricted:
    return jnp.sum(occ, axis=0, keepdims=True)

  return occ


def gamma(
  num_k: int,
  num_electrons: int,
  spin: int = 0,
  num_bands: Optional[int] = None,
  spin_restricted: bool = True
) -> Float[Array, 'spin kpt band']:
  """Calculate occupation numbers for Gamma point sampling.

  This function returns an occupation array where electrons are placed only at the Gamma point (first :math:`k`-point). For the Gamma point, occupation is 1 for occupied bands and 0 for unoccupied bands. All other :math:`k`-points have zero occupation.

  The occupation array has the following structure for each spin channel:

  .. math::

    \\begin{pmatrix}
    1 & 1 & 1 & 0 & \\cdots & 0 \\\\
    0 & 0 & 0 & 0 & \\cdots & 0 \\\\
    \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\
    0 & 0 & 0 & 0 & \\cdots & 0
    \\end{pmatrix}

  Args:
      num_k (int): The number of k-points.
      num_electrons (int): The number of electrons.
      spin (int, optional): The number of unpaired electrons. Defaults to 0.
      num_bands (int | None, optional): The number of bands (orbitals). If
          num_bands is not provided, then num_bands is the same as num_electrons.
          Defaults to None.
      spin_restricted (bool, optional): Indicate spin channel. If True, the
          first axis of output is 1. If False, the first axis of output is 2.
          Defaults to True.

  Returns:
      Float[Array, 'spin kpt band']: An occupation array with shape [num_spin, num_k, num_bands], where :math:`\text{num_spin}=1` if ``spin_restricted`` is True, else :math:`\text{num_spin}=2`. The sum of occupation array equals to :math:`\text{num_electrons}`.
  """
  num_bands = num_electrons if num_bands is None else num_bands
  occ = jnp.zeros([2, num_k, num_bands])
  occ = occ.at[0, 0, :(num_electrons + spin) // 2].set(1)
  occ = occ.at[1, 0, :(num_electrons - spin) // 2].set(1)

  if spin_restricted:
    return jnp.sum(occ, axis=0, keepdims=True)

  return occ
