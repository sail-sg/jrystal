# Copyright 2025 Garena Online Private Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Occupation module."""
from functools import partial
from typing import Optional

import einops
import jax
import jax.numpy as jnp
from jaxtyping import Array, Float

from .unitary_module import unitary_matrix, unitary_matrix_param_init


def idempotent_param_init(key: Array, num_bands: int, num_kpts: int) -> dict:
  r"""Initialize the parameters for the idempotent occupation.
  
  This function is an implementation of the method proposed in:
  
  `Li, Tianbo, et al. "Diagonalization without Diagonalization: A Direct Optimization Approach for Solid-State Density Functional Theory." arXiv preprint arXiv:2411.05033 (2024).`
    
  Please also refer to the tutorial :doc:`Occupation <../tutorial/occupation>`  for more details.
  
  Examples:

  .. code:: python
  
    from jrystal import occupation
    key = jax.random.PRNGKey(0)
    num_kpts = 1
    num_electrons = 10
    # number of bands must be greater than or equal to 
    # (num_electrons + 1) // 2 for spin-restricted calculation.
    num_bands = 10   
    params = occupation.idempotent_param_init(key, num_bands, num_kpts)
    occ = occupation.idempotent(params, num_electrons, num_kpts, spin=0)


  Args:
      key (Array): The random key for initialization.
      num_bands (int): The number of bands.
      num_kpts (int): The number of :math:`k`-points.

  Returns:
      dict: A dictionary containing the initialized parameters.

  """

  return unitary_matrix_param_init(
    key, [num_bands * num_kpts, num_bands * num_kpts], complex=False
  )


def idempotent(
  params: dict,
  num_electrons: int,
  num_kpts: int,
  spin: int = 0,
  spin_restricted: bool = True,
) -> Float[Array, 'spin kpt band']:
  r"""Calculate the occupation number using the idempotent method.
  
  This function is an implementation of the method proposed in:
  
  `Li, Tianbo, et al. "Diagonalization without Diagonalization: A Direct Optimization Approach for Solid-State Density Functional Theory." arXiv preprint arXiv:2411.05033 (2024).`
    
  Please also refer to the tutorial :doc:`Occupation <../tutorial/occupation>`  for more details.
  
  Examples:

  .. code:: python
  
    from jrystal import occupation
    key = jax.random.PRNGKey(0)
    num_kpts = 1
    num_electrons = 10
    # number of bands must be greater than or equal to 
    # (num_electrons + 1) // 2 for spin-restricted calculation.
    num_bands = 10   
    params = occupation.idempotent_param_init(key, num_bands, num_kpts)
    occ = occupation.idempotent(params, num_electrons, num_kpts, spin=0)

  Args:
      params (dict): The parameters for the idempotent occupation. It can be    generated by :func:`idempotent_param_init`.
      num_electrons (int): The number of electrons.
      num_kpts (int): The number of :math:`k`-points.
      spin (int, optional): The number of unpaired electrons. Defaults to 0.
      spin_restricted (bool, optional): Whether to use spin-restricted calculation. Defaults to True.

  Returns:
      Float[Array, 'spin kpt band']: The occupation number.
  
  """
  num_bands = params["w_re"].shape[0] // num_kpts

  def o(num_e):
    u = unitary_matrix(params, False)
    indices = jnp.arange(num_bands * num_kpts)
    mask_ones = indices < num_e * num_kpts
    mask_fraction = indices == jnp.floor(num_e * num_kpts)
    fraction = num_e * num_kpts - jnp.floor(num_e * num_kpts)
    f = jnp.where(mask_ones, 1.0, jnp.where(mask_fraction, fraction, 0.0))
    occ = einops.einsum(u, f, u.T, "nk ik, ik, ik nk -> nk")
    return occ.reshape([num_kpts, num_bands]) / num_kpts

  occ = jnp.stack(
    [o((num_electrons - spin) // 2), o((num_electrons + spin) // 2)], axis=0
  )

  if spin_restricted is False:
    return occ
  else:
    return jnp.sum(occ, axis=0, keepdims=True)


def uniform(
  num_k: int,
  num_electrons: int,
  spin: int = 0,
  num_bands: Optional[int] = None,
  spin_restricted: bool = True
) -> Float[Array, 'spin kpt band']:
  """Calculate uniform occupation numbers across k-points.

  This function returns an occupation array where electrons are distributed uniformly across :math:`k`-points. For each :math:`k`-point, the occupation is :math:`1/k` for occupied bands and 0 for unoccupied bands.

  The occupation array has the following structure for each spin channel:

  .. math::

    \\begin{pmatrix}
    1/k & 1/k & 1/k & 0 & \\cdots & 0 \\\\
    1/k & 1/k & 1/k & 0 & \\cdots & 0 \\\\
    \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\
    1/k & 1/k & 1/k & 0 & \\cdots & 0
    \\end{pmatrix}

  where :math:`k` is the number of k-points.

  Args:
      num_k (int): The number of :math:`k`-points.
      num_electrons (int): The number of electrons.
      spin (int, optional): The number of unpaired electrons. Defaults to 0.
      num_bands (int | None, optional): The number of bands (orbitals). If num_bands is not provided, then num_bands is the same as num_electrons.Defaults to None.
      spin_restricted (bool, optional): Indicate spin channel. If True, the first axis of output is 1. If False, the first axis of output is 2. Defaults to True.

  Returns:
      Float[Array, 'spin kpt band']: An occupation array with shape [num_spin, num_k, num_bands], where num_spin=1 if ``spin_restricted`` is True, else num_spin=2. The sum of occupation array equals to ``num_electrons``.
  """
  num_bands = num_electrons if num_bands is None else num_bands

  occ = jnp.zeros([2, num_k, num_bands])
  occ = occ.at[0, :, :(num_electrons + spin) // 2].set(1 / num_k)
  occ = occ.at[1, :, :(num_electrons - spin) // 2].set(1 / num_k)

  if spin_restricted:
    return jnp.sum(occ, axis=0, keepdims=True)

  return occ


def gamma(
  num_k: int,
  num_electrons: int,
  spin: int = 0,
  num_bands: Optional[int] = None,
  spin_restricted: bool = True
) -> Float[Array, 'spin kpt band']:
  r"""Calculate occupation numbers for Gamma point sampling.

  This function returns an occupation array where electrons are placed only at the Gamma point (first :math:`k`-point). For the Gamma point, occupation is 1 for occupied bands and 0 for unoccupied bands. All other :math:`k`-points have zero occupation.

  The occupation array has the following structure for each spin channel:

  .. math::

    \begin{pmatrix}
    1 & 1 & 1 & 0 & \cdots & 0 \\
    0 & 0 & 0 & 0 & \cdots & 0 \\
    \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & 0 & 0 & \cdots & 0
    \end{pmatrix}

  Args:
      num_k (int): The number of k-points.
      num_electrons (int): The number of electrons.
      spin (int, optional): The number of unpaired electrons. Defaults to 0.
      num_bands (int | None, optional): The number of bands (orbitals). If
          num_bands is not provided, then num_bands is the same as num_electrons.
          Defaults to None.
      spin_restricted (bool, optional): Indicate spin channel. If True, the
          first axis of output is 1. If False, the first axis of output is 2.
          Defaults to True.

  Returns:
      Float[Array, 'spin kpt band']: An occupation array with shape [num_spin, num_k, num_bands], where num_spin=1 if ``spin_restricted`` is True, else num_spin=2. The sum of occupation array equals to ``num_electrons``.
  """
  num_bands = num_electrons if num_bands is None else num_bands
  occ = jnp.zeros([2, num_k, num_bands])
  occ = occ.at[0, 0, :(num_electrons + spin) // 2].set(1)
  occ = occ.at[1, 0, :(num_electrons - spin) // 2].set(1)

  if spin_restricted:
    return jnp.sum(occ, axis=0, keepdims=True)

  return occ


@partial(jax.jit, static_argnames=["n_steps"])
def proj_capped_simplex(y, n: int, n_steps: int = 5):
  """Jitted version of proj_capped_simplex with static arguments for n and n_steps.
  
  This version should be used when calling from jitted contexts.
  """
  v_fn = lambda gamma: y - gamma
  x_opt_fn = lambda gamma: jnp.clip(v_fn(gamma), 0, 1)

  def lagrangian(gamma):
    x = x_opt_fn(gamma)
    return -0.5 * ((x - y)**2).sum() - gamma * (x.sum() - n)

  w_g_fn = jax.grad(lagrangian)
  w_gg_fn = jax.grad(jax.grad(lagrangian))

  # Initial value for gamma
  g_init = 0.0

  # Define a single Newton step function for scan
  def newton_step(g, _):
    g_next = g - w_g_fn(g) / w_gg_fn(g)
    return g_next, None

  # Use scan to perform n_steps of Newton's method
  g_final, _ = jax.lax.scan(newton_step, g_init, None, length=n_steps)

  return x_opt_fn(g_final)


def capped_simplex(
  params: Float[Array, 'spin kpt band'],
  num_electrons: int,
  num_kpts: int,
  spin: int = 0,
  spin_restricted: bool = True,
) -> Float[Array, 'spin kpt band']:
  n_up = (num_electrons + spin) // 2
  n_dn = (num_electrons - spin) // 2

  occ_up_flat = params[0].reshape(-1)
  # Use the jitted version with static arguments
  proj_up = proj_capped_simplex(occ_up_flat, n_up, n_steps=5)
  occ_up = proj_up.reshape([num_kpts, -1])

  occ_dn_flat = params[1].reshape(-1)
  # Use the jitted version with static arguments
  proj_dn = proj_capped_simplex(occ_dn_flat, n_dn, n_steps=5)
  occ_dn = proj_dn.reshape([num_kpts, -1])

  occ = jnp.stack([occ_up, occ_dn])

  if spin_restricted:
    return jnp.sum(occ, axis=0, keepdims=True)

  return occ
