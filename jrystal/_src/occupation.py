# Copyright 2025 Garena Online Private Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Occupation module."""
from typing import Optional, Union

import einops
import jax.numpy as jnp
from jax.lax import stop_gradient
from jaxtyping import Array, Float

from .unitary_module import unitary_matrix, unitary_matrix_param_init
from .utils import check_spin_number


def idempotent_param_init(
  key: Array,
  num_bands: int,
  num_electrons: int,
  num_kpts: int,
  spin: int = 0,
) -> dict:
  r"""Initialize the parameters for the idempotent occupation.

  This function is an implementation of the method proposed in:

  `Li, Tianbo, et al. "Diagonalization without Diagonalization: A Direct Optimization Approach for Solid-State Density Functional Theory." arXiv preprint arXiv:2411.05033 (2024).`

  Please also refer to the tutorial :doc:`Occupation <../tutorial/occupation>`  for more details.

  Examples:

  .. code:: python

    from jrystal import occupation
    key = jax.random.PRNGKey(0)
    num_kpts = 1
    num_electrons = 10
    # number of bands must be greater than or equal to
    # (num_electrons + 1) // 2 for spin-restricted calculation.
    num_bands = 10
    params = occupation.idempotent_param_init(key, num_bands, num_kpts)
    occ = occupation.idempotent(params, num_electrons, num_kpts, spin=0)


  Args:
      key (Array): The random key for initialization.
      num_bands (int): The number of bands.
      num_electrons (int): The number of electrons.
      num_kpts (int): The number of :math:`k`-points.
      spin (int, optional): The number of unpaired electrons. Defaults to 0.

  Returns:
      dict: A dictionary containing the initialized parameters.

  """

  check_spin_number(num_electrons, spin)

  num_elec_up = (num_electrons + spin) // 2
  num_elec_down = (num_electrons - spin) // 2

  param_up = unitary_matrix_param_init(
    key, [num_bands * num_kpts, num_elec_up * num_kpts], complex=False
  )

  param_down = unitary_matrix_param_init(
    key, [num_bands * num_kpts, num_elec_down * num_kpts], complex=False
  )

  return {"param_up": param_up, "param_down": param_down}


def idempotent(
  params: dict,
  num_kpts: int,
  spin_restricted: bool = True,
) -> Float[Array, 'spin kpt band']:
  r"""Calculate the occupation number using the idempotent method.

  This function is an implementation of the method proposed in:

  `Li, Tianbo, et al. "Diagonalization without Diagonalization: A Direct Optimization Approach for Solid-State Density Functional Theory." arXiv preprint arXiv:2411.05033 (2024).`

  Please also refer to the tutorial :doc:`Occupation <../tutorial/occupation>`  for more details.

  Examples:

  .. code:: python

    from jrystal import occupation
    key = jax.random.PRNGKey(0)
    num_kpts = 1
    num_electrons = 10
    # number of bands must be greater than or equal to
    # (num_electrons + 1) // 2 for spin-restricted calculation.
    num_bands = 10
    params = occupation.idempotent_param_init(key, num_bands, num_kpts)
    occ = occupation.idempotent(params, num_electrons, num_kpts, spin=0)

  Args:
      params (dict): The parameters for the idempotent occupation. It can be    generated by :func:`idempotent_param_init`.
      num_kpts (int): The number of :math:`k`-points.
      spin_restricted (bool, optional): Whether to use spin-restricted calculation. Defaults to True.

  Returns:
      Float[Array, 'spin kpt band']: The occupation number.

  """
  param_up = params["param_up"]
  param_down = params["param_down"]

  _up_shape = param_up["w_re"].shape
  _down_shape = param_down["w_re"].shape

  num_bands = _up_shape[0] // num_kpts

  def o(params):
    u = unitary_matrix(params, False)
    # [num_bands * num_kpts, num_elec_up * num_kpts]
    occ = einops.einsum(u, u.T, "nk ik, ik nk -> nk")
    return occ.reshape([num_kpts, num_bands])

  occ_up = o(param_up)
  occ_down = o(param_down)

  if spin_restricted:
    return occ_up + occ_down
  else:
    return jnp.stack([occ_up, occ_down], axis=0)


def uniform(
  num_k: int,
  num_electrons: int,
  spin: int = 0,
  num_bands: Optional[int] = None,
  spin_restricted: bool = True
) -> Float[Array, 'spin kpt band']:
  """Calculate uniform occupation numbers across k-points.

  This function returns an occupation array where electrons are distributed uniformly across :math:`k`-points. For each :math:`k`-point, the occupation is :math:`1/k` for occupied bands and 0 for unoccupied bands.

  The occupation array has the following structure for each spin channel:

  .. math::

    \\begin{pmatrix}
    1/k & 1/k & 1/k & 0 & \\cdots & 0 \\\\
    1/k & 1/k & 1/k & 0 & \\cdots & 0 \\\\
    \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\
    1/k & 1/k & 1/k & 0 & \\cdots & 0
    \\end{pmatrix}

  where :math:`k` is the number of k-points.

  Args:
      num_k (int): The number of :math:`k`-points.
      num_electrons (int): The number of electrons.
      spin (int, optional): The number of unpaired electrons. Defaults to 0.
      num_bands (int | None, optional): The number of bands (orbitals). If num_bands is not provided, then num_bands is the same as num_electrons.Defaults to None.
      spin_restricted (bool, optional): Indicate spin channel. If True, the first axis of output is 1. If False, the first axis of output is 2. Defaults to True.

  Returns:
      Float[Array, 'spin kpt band']: An occupation array with shape [num_spin, num_k, num_bands], where num_spin=1 if ``spin_restricted`` is True, else num_spin=2. The sum of occupation array equals to ``num_electrons``.
  """
  num_bands = num_electrons if num_bands is None else num_bands

  occ = jnp.zeros([2, num_k, num_bands])
  occ = occ.at[0, :, :(num_electrons + spin) // 2].set(1 / num_k)
  occ = occ.at[1, :, :(num_electrons - spin) // 2].set(1 / num_k)

  if spin_restricted:
    return jnp.sum(occ, axis=0, keepdims=True)

  return occ


def gamma(
  num_k: int,
  num_electrons: int,
  spin: int = 0,
  num_bands: Optional[int] = None,
  spin_restricted: bool = True
) -> Float[Array, 'spin kpt band']:
  r"""Calculate occupation numbers for Gamma point sampling.

  This function returns an occupation array where electrons are placed only at the Gamma point (first :math:`k`-point). For the Gamma point, occupation is 1 for occupied bands and 0 for unoccupied bands. All other :math:`k`-points have zero occupation.

  The occupation array has the following structure for each spin channel:

  .. math::

    \begin{pmatrix}
    1 & 1 & 1 & 0 & \cdots & 0 \\
    0 & 0 & 0 & 0 & \cdots & 0 \\
    \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & 0 & 0 & \cdots & 0
    \end{pmatrix}

  Args:
      num_k (int): The number of k-points.
      num_electrons (int): The number of electrons.
      spin (int, optional): The number of unpaired electrons. Defaults to 0.
      num_bands (int | None, optional): The number of bands (orbitals). If
          num_bands is not provided, then num_bands is the same as num_electrons.
          Defaults to None.
      spin_restricted (bool, optional): Indicate spin channel. If True, the
          first axis of output is 1. If False, the first axis of output is 2.
          Defaults to True.

  Returns:
      Float[Array, 'spin kpt band']: An occupation array with shape [num_spin, num_k, num_bands], where num_spin=1 if ``spin_restricted`` is True, else num_spin=2. The sum of occupation array equals to ``num_electrons``.
  """
  num_bands = num_electrons if num_bands is None else num_bands
  occ = jnp.zeros([2, num_k, num_bands])
  occ = occ.at[0, 0, :(num_electrons + spin) // 2].set(1)
  occ = occ.at[1, 0, :(num_electrons - spin) // 2].set(1)

  if spin_restricted:
    return jnp.sum(occ, axis=0, keepdims=True)

  return occ


def param_init(
  key: Array,
  num_bands: int,
  num_electrons: int,
  num_kpts: int,
  spin: int = 0,
  method: str = "fermi-dirac",
  spin_restricted: bool = True
) -> Union[dict, Float[Array, 'spin kpt band']]:
  if method == "fermi-dirac":
    return idempotent_param_init(key, num_bands, num_electrons, num_kpts, spin)
  elif method == "uniform":
    return uniform(num_kpts, num_electrons, spin, num_bands, spin_restricted)
  elif method == "gamma":
    return gamma(num_kpts, num_electrons, spin, num_bands, spin_restricted)
  else:
    raise ValueError(f"Invalid method: {method}")


def occupation(
  params: dict,
  num_kpts: int,
  method: str = "fermi-dirac",
  spin_restricted: bool = True
) -> Float[Array, 'spin kpt band']:
  if method == "fermi-dirac":
    return idempotent(params, num_kpts, spin_restricted)
  elif method == "uniform":
    return stop_gradient(params)
  elif method == "gamma":
    return stop_gradient(params)
  else:
    raise ValueError(f"Invalid method: {method}")
