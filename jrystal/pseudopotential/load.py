# Copyright 2025 Garena Online Private Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""" UPF (Unified Pseudopotential Format) parser

Ref:
  https://github.com/ltalirz/upf-schema/blob/master/upf.xsd
  https://pseudopotentials.quantum-espresso.org/home/unified-pseudopotential-format

"""
import os
import xml.etree.ElementTree as ET


def extract_value(line: str) -> str:
  """Safely extract data after a colon."""
  parts = line.split(':', 1)
  return parts[1].strip() if len(parts) > 1 else line.strip()


def parse_pp_info(pp_info_string: str) -> dict:
  """Parse the PP_INFO section into a dictionary."""
  lines = pp_info_string.split('\n')

  valence_configuration_index = None
  for idx, line in enumerate(lines):
    if "valence configuration" in line.lower():
      valence_configuration_index = idx
    if (
      valence_configuration_index and "generation configuration" in line.lower()
    ):
      valence_configuration_end_index = idx

  if valence_configuration_index is None:
    raise ValueError("pseudopotential does not find valence configuration.")

  parsed_data = {
    'Generated by':
      extract_value(lines[0]),
    'Author':
      extract_value(lines[1]),
    'Generation date':
      extract_value(lines[2]),
    'Pseudopotential type':
      extract_value(lines[3]),
    'Element':
      extract_value(lines[4]),
    'Functional':
      extract_value(lines[5]),
    'Suggested minimum cutoff for wavefunctions':
      extract_value(lines[6]),
    'Suggested minimum cutoff for charge density':
      extract_value(lines[7]),
    'Relativistic Calculation':
      lines[8].strip(),
    'Local Potential':
      extract_value(lines[9]),
    'Valence configuration':
      parse_valence_configuration(
        lines[valence_configuration_index + 2:valence_configuration_end_index +
              1]
      ),
    'Generation configuration':
      lines[-1].strip()
  }

  return parsed_data


def parse_valence_configuration(valence_lines: list) -> list:
  """Parse the valence configuration section into a list of dictionaries."""
  valence_config = []
  for line in valence_lines:
    if line.strip() and not line.startswith('Generation configuration'):
      valence_data = line.split()
      if valence_data:
        valence_entry = {
          'nl': valence_data[0],
          'pn': int(valence_data[1]),
          'l': int(valence_data[2]),
          'occ': float(valence_data[3]),
          'Rcut': float(valence_data[4]),
          'Rcut_US': float(valence_data[5]),
          'E_pseu': float(valence_data[6])
        }
      valence_config.append(valence_entry)
  return valence_config


def parse_pp_header(pp_header) -> dict:
  """Parse the PP_HEADER attributes into a dictionary."""
  return {attr: pp_header.get(attr) for attr in pp_header.keys()}


def parse_pp_mesh(pp_mesh) -> dict:
  """Parse the PP_MESH section into a dictionary."""
  mesh_info = {attr: pp_mesh.get(attr) for attr in pp_mesh.keys()}
  pp_r = [float(i) for i in pp_mesh.find('PP_R').text.split()]
  pp_rab = [float(i) for i in pp_mesh.find('PP_RAB').text.split()]
  return {'info': mesh_info, 'PP_R': pp_r, 'PP_RAB': pp_rab}


def parse_pp_nonlocal(pp_nonlocal) -> dict:
  """Parse the PP_NONLOCAL section into a dictionary."""

  nonlocal_dict = {}

  # beta_elements = pp_nonlocal.findall('.//PP_BETA.1')
  beta_elements = [
    elem for elem in pp_nonlocal if elem.tag.startswith('PP_BETA')
  ]
  if beta_elements:
    nonlocal_dict['PP_BETA'] = []
    for beta in beta_elements:
      nonlocal_dict['PP_BETA'].append(
        {
          'index': beta.get('index'),
          'label': beta.get('label'),
          'angular_momentum': beta.get('angular_momentum'),
          'cutoff_radius_index': beta.get('cutoff_radius_index'),
          'cutoff_radius': beta.get('cutoff_radius'),
          'ultrasoft_cutoff_radius': beta.get('ultrasoft_cutoff_radius'),
          'values': list(map(float, beta.text.split()))
        }
      )

  dij_element = pp_nonlocal.find('PP_DIJ')
  if dij_element is not None:
    nonlocal_dict['PP_DIJ'] = list(map(float, dij_element.text.split()))

  augmentation_element = pp_nonlocal.find('PP_AUGMENTATION')
  if augmentation_element is not None:
    augmentation_data = {
      'q_with_l': augmentation_element.get('q_with_l') == 'true',
      'nqf': int(augmentation_element.get('nqf')),
      'nqlc': int(augmentation_element.get('nqlc')),
    }

    # Parse <PP_Q>
    q_element = augmentation_element.find('PP_Q')
    if q_element is not None:
      augmentation_data['PP_Q'] = list(map(float, q_element.text.split()))

    # Parse multiple <PP_QIJ> elements
    # qij_elements = augmentation_element.findall('.//PP_QIJ.1.1')
    qij_elements = [
      elem for elem in augmentation_element if elem.tag.startswith('PP_QIJ')
    ]
    if qij_elements:
      augmentation_data['PP_QIJ'] = []
      for qij in qij_elements:
        augmentation_data['PP_QIJ'].append(
          {
            'first_index': qij.get('first_index'),
            'second_index': qij.get('second_index'),
            'composite_index': qij.get('composite_index'),
            'values': list(map(float, qij.text.split()))
          }
        )

    nonlocal_dict['PP_AUGMENTATION'] = augmentation_data
  return nonlocal_dict


def parse_pp_local(pp_local) -> list:
  """Parse the PP_LOCAL section into a list of floats."""
  return [float(i) for i in pp_local.text.split()]


def parse_upf(filepath: str) -> dict:
  """Main function to parse a UPF file.
    The schema of upf can be find https://github.com/ltalirz/upf-schema.

    Usage:
      Mesh_grid: dict["PP_MESH"]["PP_R"]
      Local part: dict["PP_LOCAL"]
      Nonlocal part:
          Beta: dict["PP_NONLOCAL"]["BETA"]['values']
          D_ij: dict["PP_NONLOCAL"]["D_IJ"]['values']

  """
  root = ET.parse(filepath)

  pp_info = parse_pp_info(root.find('PP_INFO').text.strip())
  header_info = parse_pp_header(root.find('PP_HEADER'))
  mesh_info = parse_pp_mesh(root.find('PP_MESH'))
  nonlocal_dict = parse_pp_nonlocal(root.find('PP_NONLOCAL'))
  local_dict = parse_pp_local(root.find('PP_LOCAL'))

  return {
    'PP_INFO': pp_info,
    'PP_HEADER': header_info,
    'PP_MESH': mesh_info,
    'PP_NONLOCAL': nonlocal_dict,
    'PP_LOCAL': local_dict,
  }


def find_upf(dir_path: str, atom: str) -> str:
  """Find the pseudopotential file of an atom in the directory path.

  The pseudo potential file must start with the
      "$atom_symbol$.$xc_functional$.*.upf"

  Args:
    dir_path (str): The directory path for pseudopotential files in UPF format.
      The directory must contain only one file per element.
    atom (str): The symbol for the element.

  Returns:
      str: The upf file path.
  """

  for file_name in os.listdir(dir_path):
    file_name_lower = file_name.lower()
    if (
      file_name_lower.startswith(atom.lower() + ".") and
      file_name_lower.endswith("upf")
    ):
      return dir_path + file_name

  raise ValueError(
    f"The pseudopotential file of element \'{atom}\' is not found in directory"
    f"{dir_path}"
  )
